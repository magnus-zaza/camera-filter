<!doctype html>
<!--
  Hat Filter - Fun Video Filter Studio
  Copyright (c) 2025 Magnus Zaza. All rights reserved.
  Licensed under the MIT License. See LICENSE file for details.
  
  Uses MediaPipe Face Mesh (Apache 2.0) for face tracking.
  
  OVERVIEW:
  This is a real-time face filter application that overlays various hat designs
  on the user's head using webcam feed and face landmark detection. The app
  supports multiple hat types, bilingual interface (English/Arabic), and
  customizable hat text.
-->
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hat Filter Studio</title>
  
  <!-- Preconnect to Google Fonts for faster loading -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Cairo font for Arabic language support -->
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
  
  <style>
    /* ============================================
       CSS VARIABLES AND GLOBAL STYLES
       ============================================ */
    
    /* Root variables - applies to all elements */
    :root {
      color-scheme: light dark; /* Enable dark mode support */
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* RTL (Right-to-Left) specific font stack for Arabic */
    [dir="rtl"] {
      font-family: "Cairo", "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* Body styling - creates centered layout with gradient background */
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 48px 24px;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 35%, #0b1120 100%);
      color: #0f172a;
    }

    /* ============================================
       LANGUAGE SELECTOR STYLES
       ============================================ */
    
    /* Language selector positioned at top-right */
    .language-selector {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100; /* Ensure it stays above other elements */
    }

    /* In RTL mode, move to top-left instead */
    [dir="rtl"] .language-selector {
      right: auto;
      left: 20px;
    }

    /* Language dropdown styling */
    .language-selector select {
      padding: 8px 16px;
      border-radius: 10px;
      border: 1px solid rgba(226, 232, 240, 0.3);
      background: rgba(15, 23, 42, 0.8);
      color: #e2e8f0;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px); /* Blur effect for glass-morphism */
    }

    /* Hover state for language selector */
    .language-selector select:hover {
      background: rgba(15, 23, 42, 0.95);
      border-color: rgba(226, 232, 240, 0.5);
    }

    /* Focus state for accessibility */
    .language-selector select:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    /* ============================================
       ANIMATIONS
       ============================================ */
    
    /* Spinning animation for loading button indicator */
    @keyframes button-spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* ============================================
       LAYOUT COMPONENTS
       ============================================ */
    
    /* Main application container - responsive width */
    .app-shell {
      width: min(960px, 100%);
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    /* Header section styling */
    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      color: #e2e8f0;
    }

    /* Main title with responsive sizing using clamp */
    .hero-title {
      font-size: clamp(32px, 4vw, 44px);
      font-weight: 700;
      letter-spacing: -0.5px;
      margin: 0;
    }

    .hero-subtitle {
      font-size: clamp(16px, 2vw, 20px);
      color: rgba(226, 232, 240, 0.85);
      margin: 0;
    }

    .card {
      background: rgba(255, 255, 255, 0.94);
      border-radius: 24px;
      padding: clamp(20px, 3vw, 32px);
      backdrop-filter: blur(14px);
      box-shadow: 0 40px 80px rgba(15, 23, 42, 0.45);
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .control-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      align-items: center;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field label {
      font-size: 14px;
      font-weight: 600;
      color: #475569;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .input-text {
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(248, 250, 252, 0.85);
      font-size: 16px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .input-text:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
    }

    .button-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 14px;
      padding: 12px 20px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    button:focus-visible {
      outline: 3px solid rgba(37, 99, 235, 0.55);
      outline-offset: 2px;
    }

    .btn-primary.is-busy {
      position: relative;
      color: rgba(255, 255, 255, 0.76);
    }

    .btn-primary.is-busy::after {
      content: "";
      position: absolute;
      right: 18px;
      top: 50%;
      width: 16px;
      height: 16px;
      margin-top: -8px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-top-color: transparent;
      animation: button-spin 0.8s linear infinite;
    }

    .btn-primary {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: #fff;
      box-shadow: 0 18px 24px rgba(37, 99, 235, 0.35);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 22px 30px rgba(37, 99, 235, 0.4);
    }

    .btn-ghost {
      background: rgba(37, 99, 235, 0.08);
      color: #1d4ed8;
    }

    .btn-ghost:hover:not(:disabled) {
      background: rgba(37, 99, 235, 0.15);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .stage {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: radial-gradient(circle at 50% 20%, rgba(56, 189, 248, 0.35), rgba(14, 116, 144, 0.1) 35%, rgba(15, 23, 42, 0.85) 75%);
      border-radius: 20px;
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .stage::before,
    .stage::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    .stage::before {
      background: radial-gradient(circle at 80% 15%, rgba(59, 130, 246, 0.25), transparent 55%),
        radial-gradient(circle at 20% 85%, rgba(236, 72, 153, 0.22), transparent 50%);
      mix-blend-mode: screen;
    }

    .stage::after {
      inset: 14px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      mix-blend-mode: overlay;
    }

    .stage-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 12px;
      padding: 0 32px;
      text-align: center;
      color: rgba(226, 232, 240, 0.92);
      background: linear-gradient(160deg, rgba(15, 23, 42, 0.85), rgba(30, 64, 175, 0.55));
      backdrop-filter: blur(6px);
      z-index: 1;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      pointer-events: none;
    }

    .stage-placeholder.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .placeholder-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(96, 165, 250, 0.28);
      font-size: 13px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      font-weight: 700;
    }

    .placeholder-title {
      margin: 0;
      font-size: clamp(22px, 3vw, 30px);
      font-weight: 700;
      letter-spacing: -0.25px;
    }

    .placeholder-subtitle {
      margin: 0;
      font-size: clamp(14px, 2.2vw, 18px);
      color: rgba(226, 232, 240, 0.78);
      max-width: 420px;
      line-height: 1.6;
    }

    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }

    .hat {
      position: absolute;
      top: 32%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 220px;
      pointer-events: none;
      z-index: 2;
      opacity: 0;
      transition: opacity 0.18s ease;
    }

    .hat svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .hat-name {
      position: absolute;
      left: 50%;
      top: 58%;
      transform: translate(-50%, -50%);
      font-weight: 700;
      letter-spacing: 0.16em;
      color: #ffe27a;
      text-shadow: 0 3px 18px rgba(15, 23, 42, 0.75);
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.18s ease;
      font-size: clamp(14px, 3.2vw, 28px);
    }

    .secondary-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      justify-content: space-between;
      align-items: center;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .slider-group label {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #475569;
    }

    input[type="range"] {
      accent-color: #2563eb;
      width: 180px;
    }

    .note {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 14px 18px;
      border-radius: 16px;
      background: rgba(37, 99, 235, 0.08);
      color: #1e293b;
      font-size: 15px;
      line-height: 1.6;
    }

    .note-icon {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(37, 99, 235, 0.15);
      color: #1d4ed8;
      font-weight: 700;
    }

    .status {
      min-height: 1.4em;
      font-weight: 600;
      color: #0f172a;
      display: flex;
      justify-content: flex-end;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.08);
      font-size: 14px;
      font-weight: 600;
      color: #1e293b;
    }

    .status-pill.ready {
      color: #15803d;
    }

    .status-pill.alert {
      color: #b91c1c;
    }

    .status-pill.warn {
      color: #b45309;
    }

    .status-pill.idle {
      color: #475569;
    }

    .status-pill::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #38bdf8;
      box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.24);
    }

    .status-pill.ready::before {
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.25);
    }

    .status-pill.alert::before {
      background: #ef4444;
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.24);
    }

    .status-pill.idle::before {
      background: #94a3b8;
      box-shadow: 0 0 0 4px rgba(148, 163, 184, 0.24);
    }

    .status-pill.warn::before {
      background: #f59e0b;
      box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.24);
    }

    footer {
      color: rgba(226, 232, 240, 0.6);
      font-size: 14px;
      text-align: center;
    }

    footer a {
      color: rgba(148, 197, 255, 0.9);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 720px) {
      .card {
        border-radius: 20px;
        padding: 20px;
      }

      .secondary-controls {
        flex-direction: column;
        align-items: stretch;
      }

      input[type="range"] {
        width: 100%;
      }

      .status {
        justify-content: flex-start;
      }
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: radial-gradient(circle at top, rgba(37, 99, 235, 0.25), rgba(15, 23, 42, 1));
        color: #e2e8f0;
      }

      .card {
        background: rgba(15, 23, 42, 0.72);
        border: 1px solid rgba(148, 163, 184, 0.18);
        color: #e2e8f0;
      }

      .field label,
      .slider-group label {
        color: rgba(226, 232, 240, 0.75);
      }

      .input-text {
        background: rgba(15, 23, 42, 0.6);
        border-color: rgba(148, 163, 184, 0.35);
        color: #f8fafc;
      }

      .btn-ghost {
        background: rgba(37, 99, 235, 0.18);
        color: #bfdbfe;
      }

      .btn-ghost:hover:not(:disabled) {
        background: rgba(37, 99, 235, 0.28);
      }

      .note {
        background: rgba(37, 99, 235, 0.18);
        color: #f8fafc;
      }

      .status-pill {
        background: rgba(148, 163, 184, 0.18);
        color: #cbd5f5;
      }

      .status-pill.ready {
        color: #86efac;
      }

      .status-pill.alert {
        color: #fca5a5;
      }

      .status-pill.warn {
        color: #fcd34d;
      }

      .status-pill.idle {
        color: #cbd5f5;
      }
    }
  </style>

</head>
<body>
  <div class="language-selector">
    <select id="languageSelect" aria-label="Select language">
      <option value="en">English</option>
      <option value="ar" selected>العربية</option>
    </select>
  </div>
  <div class="app-shell">
    <header>
      <h1 class="hero-title" data-i18n="title">Patrol Mode Studio</h1>
      <p class="hero-subtitle" data-i18n="subtitle">Slip on your digital police cap, customize the badge name, and bring the fun to any call.</p>
    </header>

    <section class="card">
      <div class="control-bar">
        <div class="field">
          <label for="hatType" data-i18n="hatType">Hat type</label>
          <select id="hatType" class="input-text" style="cursor: pointer;">
            <option value="police" data-i18n-option="hatPolice">Police</option>
            <option value="chef" data-i18n-option="hatChef">Chef</option>
            <option value="wizard" data-i18n-option="hatWizard">Wizard</option>
            <option value="cowboy" data-i18n-option="hatCowboy">Cowboy</option>
            <option value="party" data-i18n-option="hatParty">Party</option>
          </select>
        </div>
        <div class="field">
          <label for="name" data-i18n="displayName">Display name</label>
          <input id="name" class="input-text" type="text" data-i18n-placeholder="namePlaceholder" placeholder="Type the badge name..." autocomplete="off" />
        </div>
        <div class="field">
          <label data-i18n="sessionControls">Session controls</label>
          <div class="button-row">
            <button id="startBtn" type="button" class="btn-primary" data-i18n="startCamera">Start camera</button>
            <button id="stopBtn" type="button" class="btn-ghost" disabled data-i18n="stopCamera">Stop camera</button>
          </div>
        </div>
      </div>

      <div id="stage" class="stage">
        <div id="stagePlaceholder" class="stage-placeholder" aria-hidden="true">
          <span class="placeholder-badge" data-i18n="livePreview">Live Preview</span>
          <h2 class="placeholder-title" data-i18n="readyTitle">Ready when you are</h2>
          <p class="placeholder-subtitle" data-i18n="readySubtitle">Start the camera to unlock the tracker and watch the hat snap into place.</p>
        </div>
        <video id="video" playsinline autoplay muted></video>
        <div id="hat" class="hat" role="img" aria-label="Hat overlay">
          <!-- Police Hat -->
          <svg id="hat-police" class="hat-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 380">
            <defs>
              <linearGradient id="policeGradient" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0" stop-color="#2b2f38" />
                <stop offset="1" stop-color="#0d0f14" />
              </linearGradient>
            </defs>
            <path d="M50 240 C150 190, 450 190, 550 240 C460 320, 140 320, 50 240 Z" fill="#141822" stroke="#000" stroke-opacity="0.35" stroke-width="6" />
            <path d="M120 230 C160 120, 440 120, 480 230 C410 205, 190 205, 120 230 Z" fill="url(#policeGradient)" stroke="#000" stroke-opacity="0.35" stroke-width="6" />
            <rect x="150" y="210" width="300" height="44" rx="18" fill="#121621" opacity="0.95" />
            <path d="M300 150 C330 170, 360 190, 360 220 C360 270, 325 300, 300 312 C275 300, 240 270, 240 220 C240 190, 270 170, 300 150 Z" fill="#f2c14e" stroke="#9a6f10" stroke-width="8" />
            <circle cx="300" cy="230" r="22" fill="#ffe08a" stroke="#9a6f10" stroke-width="6" />
          </svg>
          
          <!-- Chef Hat -->
          <svg id="hat-chef" class="hat-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 380" style="display: none;">
            <ellipse cx="300" cy="180" rx="180" ry="100" fill="#ffffff" stroke="#e5e5e5" stroke-width="4" />
            <ellipse cx="200" cy="140" rx="60" ry="75" fill="#ffffff" stroke="#e5e5e5" stroke-width="4" />
            <ellipse cx="300" cy="120" rx="70" ry="85" fill="#ffffff" stroke="#e5e5e5" stroke-width="4" />
            <ellipse cx="400" cy="140" rx="60" ry="75" fill="#ffffff" stroke="#e5e5e5" stroke-width="4" />
            <rect x="150" y="220" width="300" height="80" rx="8" fill="#ffffff" stroke="#e5e5e5" stroke-width="4" />
            <rect x="160" y="235" width="280" height="12" fill="#f0f0f0" />
          </svg>
          
          <!-- Wizard Hat -->
          <svg id="hat-wizard" class="hat-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 380" style="display: none;">
            <defs>
              <linearGradient id="wizardGradient" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0" stop-color="#4a148c" />
                <stop offset="1" stop-color="#1a0033" />
              </linearGradient>
            </defs>
            <path d="M300 40 L100 260 L500 260 Z" fill="url(#wizardGradient)" stroke="#6a1b9a" stroke-width="4" />
            <ellipse cx="300" cy="260" rx="210" ry="35" fill="#4a148c" stroke="#6a1b9a" stroke-width="4" />
            <path d="M280 80 L300 100 L285 140 L310 130 L305 170 L325 155 L315 190" fill="none" stroke="#ffd700" stroke-width="3" />
            <circle cx="250" cy="150" r="8" fill="#ffd700" />
            <circle cx="350" cy="180" r="6" fill="#ffd700" />
            <circle cx="320" cy="220" r="7" fill="#ffd700" />
          </svg>
          
          <!-- Cowboy Hat -->
          <svg id="hat-cowboy" class="hat-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 380" style="display: none;">
            <defs>
              <linearGradient id="cowboyGradient" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0" stop-color="#8b4513" />
                <stop offset="1" stop-color="#5a2d0c" />
              </linearGradient>
            </defs>
            <ellipse cx="300" cy="250" rx="240" ry="45" fill="url(#cowboyGradient)" stroke="#3e1f06" stroke-width="4" />
            <path d="M300 100 Q280 120, 270 160 Q265 200, 250 220 L350 220 Q335 200, 330 160 Q320 120, 300 100 Z" fill="url(#cowboyGradient)" stroke="#3e1f06" stroke-width="4" />
            <path d="M100 240 Q150 200, 250 220 L350 220 Q450 200, 500 240" fill="url(#cowboyGradient)" stroke="#3e1f06" stroke-width="4" />
            <rect x="280" y="200" width="40" height="20" rx="3" fill="#654321" stroke="#3e1f06" stroke-width="2" />
          </svg>
          
          <!-- Party Hat -->
          <svg id="hat-party" class="hat-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 380" style="display: none;">
            <defs>
              <linearGradient id="partyGradient" x1="0" x2="1" y1="0" y2="1">
                <stop offset="0" stop-color="#ff1744" />
                <stop offset="0.33" stop-color="#ffeb3b" />
                <stop offset="0.66" stop-color="#00e676" />
                <stop offset="1" stop-color="#2979ff" />
              </linearGradient>
            </defs>
            <path d="M300 50 L120 280 L480 280 Z" fill="url(#partyGradient)" stroke="#1565c0" stroke-width="4" />
            <circle cx="300" cy="50" r="20" fill="#ffd700" stroke="#f57f17" stroke-width="3" />
            <line x1="200" y1="140" x2="400" y2="140" stroke="#ffffff" stroke-width="8" opacity="0.7" />
            <line x1="170" y1="200" x2="430" y2="200" stroke="#ffffff" stroke-width="8" opacity="0.7" />
            <line x1="140" y1="260" x2="460" y2="260" stroke="#ffffff" stroke-width="8" opacity="0.7" />
            <circle cx="250" cy="100" r="6" fill="#ffffff" />
            <circle cx="350" cy="110" r="6" fill="#ffffff" />
            <circle cx="220" cy="170" r="6" fill="#ffffff" />
            <circle cx="380" cy="175" r="6" fill="#ffffff" />
          </svg>
          
          <div id="hatName" class="hat-name"></div>
        </div>
      </div>

      <div class="secondary-controls">
        <div class="slider-group">
          <label for="sizeRange" data-i18n="hatSize">Hat size</label>
          <input id="sizeRange" type="range" min="0.6" max="2.0" step="0.1" value="1.2" />
        </div>
        <div class="button-row">
          <button id="centerBtn" type="button" class="btn-ghost" data-i18n="recenterHat">Recenter hat</button>
          <button id="fullscreenBtn" type="button" class="btn-ghost" data-i18n="fullscreen">Fullscreen</button>
        </div>
        <div id="status" class="status" aria-live="polite">
          <span id="statusPill" class="status-pill" data-i18n="waitingToBegin">Waiting to begin</span>
        </div>
      </div>

      <div class="note">
      <br>
      <small style="margin-top: 8px; display: block; opacity: 0.7;">© 2025 Magnus Zaza. All rights reserved.</small>
        <span class="note-icon">i</span>
        <span data-i18n="noteText">Face the camera with even lighting for reliable tracking. Adjust the hat size or badge name any time.</span>
      </div>
    </section>

    <footer data-i18n="footer">
      Built for playful patrol vibes. Grant camera access when prompted to dive in.
    </footer>
  </div>

  <script>
    'use strict';
    const nameInput = document.getElementById('name');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stage = document.getElementById('stage');
    const video = document.getElementById('video');
    const stagePlaceholder = document.getElementById('stagePlaceholder');
    const hat = document.getElementById('hat');
    const hatName = document.getElementById('hatName');
    const sizeRange = document.getElementById('sizeRange');
    const centerBtn = document.getElementById('centerBtn');
    const statusEl = document.getElementById('status');
    const statusPill = document.getElementById('statusPill');
    const languageSelect = document.getElementById('languageSelect');
    const hatTypeSelect = document.getElementById('hatType');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    let currentHatType = 'police';
    let isFullscreen = false;

    function toggleFullscreen() {
      if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
        // Enter fullscreen
        const elem = stage;
        if (elem.requestFullscreen) {
          elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) {
          elem.webkitRequestFullscreen();
        } else if (elem.mozRequestFullScreen) {
          elem.mozRequestFullScreen();
        } else if (elem.msRequestFullscreen) {
          elem.msRequestFullscreen();
        }
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
    }

    function updateFullscreenButton() {
      isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);
      if (isFullscreen) {
        fullscreenBtn.textContent = getStatusMessage('exitFullscreen');
      } else {
        fullscreenBtn.textContent = getStatusMessage('fullscreen');
      }
    }

    // Listen for fullscreen changes
    document.addEventListener('fullscreenchange', updateFullscreenButton);
    document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
    document.addEventListener('mozfullscreenchange', updateFullscreenButton);
    document.addEventListener('MSFullscreenChange', updateFullscreenButton);

    fullscreenBtn.addEventListener('click', toggleFullscreen);

    function switchHat(hatType) {
      currentHatType = hatType;
      // Hide all hats
      document.querySelectorAll('.hat-svg').forEach(svg => {
        svg.style.display = 'none';
      });
      // Show selected hat
      const selectedHat = document.getElementById('hat-' + hatType);
      if (selectedHat) {
        selectedHat.style.display = 'block';
      }
    }

    hatTypeSelect.addEventListener('change', (e) => {
      switchHat(e.target.value);
    });

    // Translation dictionary
    const translations = {
      en: {
        title: 'Hat Filter Studio',
        subtitle: 'Choose your favorite hat, customize it with your name, and add fun to any video call.',
        hatType: 'Hat type',
        hatPolice: 'Police',
        hatChef: 'Chef',
        hatWizard: 'Wizard',
        hatCowboy: 'Cowboy',
        hatParty: 'Party',
        displayName: 'Display name',
        namePlaceholder: 'Type the badge name...',
        sessionControls: 'Session controls',
        startCamera: 'Start camera',
        stopCamera: 'Stop camera',
        livePreview: 'Live Preview',
        readyTitle: 'Ready when you are',
        readySubtitle: 'Start the camera to unlock the tracker and watch the hat snap into place.',
        hatSize: 'Hat size',
        recenterHat: 'Recenter hat',
        fullscreen: 'Fullscreen',
        exitFullscreen: 'Exit fullscreen',
        waitingToBegin: 'Waiting to begin',
        noteText: 'Face the camera with even lighting for reliable tracking. Adjust the hat size or badge name any time.',
        footer: 'Built for fun video calls. Grant camera access when prompted to dive in.',
        statusLookingForFace: 'Looking for a face...',
        statusHatLocked: 'Hat locked in!',
        statusPreparing: 'Preparing session...',
        statusLoading: 'Loading tracking libraries...',
        statusStartingCamera: 'Starting camera...',
        statusMoveIntoView: 'Move into view so the hat can lock on.',
        statusIdle: 'Camera idle. Hit start when you are ready.',
        statusReset: 'Tracking reset. Hold still for a moment.',
        statusAllSet: 'All set',
        statusWorking: 'Working...',
        statusActionNeeded: 'Action needed',
        statusHoldSteady: 'Hold steady'
      },
      ar: {
        title: 'استوديو فلتر القبعات',
        subtitle: 'اختر قبعتك المفضلة، خصصها باسمك، وأضف المرح إلى أي مكالمة فيديو.',
        hatType: 'نوع القبعة',
        hatPolice: 'شرطة',
        hatChef: 'طباخ',
        hatWizard: 'ساحر',
        hatCowboy: 'راعي بقر',
        hatParty: 'حفلة',
        displayName: 'اسم العرض',
        namePlaceholder: 'اكتب اسم الشارة...',
        sessionControls: 'عناصر التحكم',
        startCamera: 'تشغيل الكاميرا',
        stopCamera: 'إيقاف الكاميرا',
        livePreview: 'معاينة مباشرة',
        readyTitle: 'جاهز عندما تكون مستعداً',
        readySubtitle: 'ابدأ تشغيل الكاميرا لفتح التتبع ومشاهدة القبعة تثبت في مكانها.',
        hatSize: 'حجم القبعة',
        recenterHat: 'إعادة توسيط القبعة',
        fullscreen: 'ملء الشاشة',
        exitFullscreen: 'الخروج من ملء الشاشة',
        waitingToBegin: 'في انتظار البدء',
        noteText: 'واجه الكاميرا بإضاءة متساوية للحصول على تتبع موثوق. اضبط حجم القبعة أو اسم الشارة في أي وقت.',
        footer: 'مصمم لمكالمات فيديو ممتعة. امنح الوصول للكاميرا عندما يُطلب منك ذلك.',
        statusLookingForFace: 'البحث عن وجه...',
        statusHatLocked: 'القبعة مثبتة!',
        statusPreparing: 'جاري التحضير...',
        statusLoading: 'تحميل مكتبات التتبع...',
        statusStartingCamera: 'بدء تشغيل الكاميرا...',
        statusMoveIntoView: 'تحرك إلى العرض حتى تتمكن القبعة من التثبيت.',
        statusIdle: 'الكاميرا في وضع الخمول. اضغط على بدء عندما تكون جاهزاً.',
        statusReset: 'إعادة تعيين التتبع. امكث ثابتاً للحظة.',
        statusAllSet: 'كل شيء جاهز',
        statusWorking: 'جاري العمل...',
        statusActionNeeded: 'مطلوب إجراء',
        statusHoldSteady: 'ابق ثابتاً'
      }
    };

    let currentLanguage = 'ar';

    function setLanguage(lang) {
      currentLanguage = lang;
      document.documentElement.setAttribute('lang', lang);
      document.documentElement.setAttribute('dir', lang === 'ar' ? 'rtl' : 'ltr');
      
      // Update all elements with data-i18n attribute
      document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (translations[lang] && translations[lang][key]) {
          element.textContent = translations[lang][key];
        }
      });

      // Update placeholder
      const placeholderKey = nameInput.getAttribute('data-i18n-placeholder');
      if (placeholderKey && translations[lang] && translations[lang][placeholderKey]) {
        nameInput.placeholder = translations[lang][placeholderKey];
      }

      // Update select options
      document.querySelectorAll('option[data-i18n-option]').forEach(option => {
        const key = option.getAttribute('data-i18n-option');
        if (translations[lang] && translations[lang][key]) {
          option.textContent = translations[lang][key];
        }
      });

      // Update page title
      document.title = translations[lang].title;
    }

    function getStatusMessage(key) {
      return translations[currentLanguage][key] || key;
    }

    languageSelect.addEventListener('change', (e) => {
      setLanguage(e.target.value);
    });

    const CAMERA_UTIL_URLS = [
      'libs/camera_utils.js',
      'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.1.1679/camera_utils.js',
      'https://unpkg.com/@mediapipe/camera_utils@0.1.1679/camera_utils.js',
      'https://fastly.jsdelivr.net/npm/@mediapipe/camera_utils@0.1.1679/camera_utils.js'
    ];

    const FACE_MESH_URLS = [
      'libs/face_mesh.js',
      'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1637/face_mesh.js',
      'https://unpkg.com/@mediapipe/face_mesh@0.4.1637/face_mesh.js',
      'https://fastly.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1637/face_mesh.js'
    ];

    const LOCAL_FACE_MESH_ASSETS = new Set([
      'face_mesh_solution_packed_assets_loader.js',
      'face_mesh_solution_simd_wasm_bin.js',
      'face_mesh_solution_simd_wasm_bin.wasm',
      'face_mesh.binarypb'
    ]);

    const HAT_ASPECT = 380 / 600;
    const SMOOTHING = 0.25;

    let faceMesh = null;
    let camera = null;
    let smoothedPose = null;
    let trackingActive = false;
    let sizeMultiplier = parseFloat(sizeRange.value);
    let lastFaceTs = 0;
    let libraryLoadPromise = null;

    const loadedScripts = new Set();

    // Color-coded status messaging for the pill indicator.
    function setStatus(message, tone = 'info') {
      if (!statusEl || !statusPill) {
        return;
      }
      const trimmed = message ? message.trim() : '';
      let fallback = getStatusMessage('statusWorking');
      if (tone === 'ready') fallback = getStatusMessage('statusAllSet');
      else if (tone === 'idle') fallback = getStatusMessage('waitingToBegin');
      else if (tone === 'error') fallback = getStatusMessage('statusActionNeeded');
      else if (tone === 'warn') fallback = getStatusMessage('statusHoldSteady');

      statusPill.textContent = trimmed || fallback;
      statusPill.classList.remove('ready', 'alert', 'idle', 'warn');
      if (tone === 'ready') {
        statusPill.classList.add('ready');
      } else if (tone === 'error') {
        statusPill.classList.add('alert');
      } else if (tone === 'idle') {
        statusPill.classList.add('idle');
      } else if (tone === 'warn') {
        statusPill.classList.add('warn');
      }
      statusEl.hidden = false;
    }

    function setStartLoading(isLoading) {
      if (isLoading) {
        startBtn.classList.add('is-busy');
      } else {
        startBtn.classList.remove('is-busy');
      }
    }

    function loadScriptOnce(url) {
      if (loadedScripts.has(url)) {
        return Promise.resolve();
      }

      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.onload = () => {
          loadedScripts.add(url);
          resolve();
        };
        script.onerror = () => {
          script.remove();
          reject(new Error('Failed to load ' + url));
        };
        document.head.appendChild(script);
      });
    }

    async function loadWithFallback(urls, label) {
      let lastError = null;
      for (const url of urls) {
        try {
          await loadScriptOnce(url);
          return;
        } catch (error) {
          lastError = error;
          console.warn(`Failed to load ${label} from ${url}`, error);
        }
      }
      const message = lastError
        ? `Failed to load ${label}. Last error: ${lastError.message}`
        : `Failed to load ${label}. No URLs provided.`;
      throw new Error(message);
    }

    async function ensureLibrariesLoaded() {
      if (libraryLoadPromise) return libraryLoadPromise;

      libraryLoadPromise = (async () => {
        await loadWithFallback(CAMERA_UTIL_URLS, 'camera_utils');
        await loadWithFallback(FACE_MESH_URLS, 'face_mesh');
      })();

      return libraryLoadPromise;
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function mirrorX(x, width) {
      return (1 - x) * width;
    }

    function computePose(landmarks) {
      const width = stage.clientWidth;
      const height = stage.clientHeight;
      if (!width || !height) return null;

      const top = landmarks[10];
      const left = landmarks[234];
      const right = landmarks[454];
      if (!top || !left || !right) return null;

      const leftX = mirrorX(left.x, width);
      const leftY = left.y * height;
      const rightX = mirrorX(right.x, width);
      const rightY = right.y * height;
      const topX = mirrorX(top.x, width);
      const topY = top.y * height;
      const headWidth = Math.hypot(rightX - leftX, rightY - leftY);
      if (!headWidth) return null;

      const hatWidth = headWidth * 1.55 * sizeMultiplier;
      const hatHeight = hatWidth * HAT_ASPECT;
      const centerX = topX;
      const centerY = topY - hatHeight * 0.55;

      return { x: centerX, y: centerY, width: hatWidth };
    }

    function applyPose(pose) {
      hat.style.left = `${pose.x}px`;
      hat.style.top = `${pose.y}px`;
      hat.style.width = `${pose.width}px`;
      hat.style.opacity = 1;
      hat.style.transform = 'translate(-50%, -50%)';

      if (hatName.textContent) {
        const fontSize = Math.max(14, Math.min(36, pose.width * 0.12));
        hatName.style.fontSize = `${fontSize}px`;
        hatName.style.opacity = 1;
      }
    }

    function fadeHat() {
      hat.style.opacity = 0;
      hatName.style.opacity = 0;
    }

    function onResults(results) {
      const face = results.multiFaceLandmarks && results.multiFaceLandmarks[0];
      if (!trackingActive) return;

      if (!face) {
        const now = performance.now();
        if (now - lastFaceTs > 800) {
          setStatus(getStatusMessage('statusLookingForFace'), 'warn');
        }
        fadeHat();
        return;
      }

      lastFaceTs = performance.now();
      setStatus(getStatusMessage('statusHatLocked'), 'ready');
      const targetPose = computePose(face);
      if (!targetPose) {
        fadeHat();
        return;
      }

      if (!smoothedPose) {
        smoothedPose = targetPose;
      } else {
        smoothedPose = {
          x: lerp(smoothedPose.x, targetPose.x, SMOOTHING),
          y: lerp(smoothedPose.y, targetPose.y, SMOOTHING),
          width: lerp(smoothedPose.width, targetPose.width, SMOOTHING)
        };
      }

      applyPose(smoothedPose);
    }

    function getFaceMeshCtor() {
      const lib = window.FaceMesh || window.faceMesh || window.mpFaceMesh;
      if (!lib) return null;
      return lib.FaceMesh || lib;
    }

    function getCameraCtor() {
      return window.Camera || window.CameraUtils?.Camera || null;
    }

    async function start() {
      if (trackingActive) return;

      setStatus(getStatusMessage('statusPreparing'));
      if (!navigator.mediaDevices?.getUserMedia) {
        setStatus('Camera API not supported in this browser.', 'error');
        return;
      }

      setStartLoading(true);
      startBtn.disabled = true;

      try {
        setStatus(getStatusMessage('statusLoading'));
        await ensureLibrariesLoaded();
      } catch (error) {
        console.error('Tracking library load failed', error);
        setStatus('Could not load tracking libraries: ' + (error?.message || 'unknown error') + '. If you are offline, download the scripts into ./libs and try again.', 'error');
        setStartLoading(false);
        startBtn.disabled = false;
        return;
      }

      const FaceMeshCtor = getFaceMeshCtor();
      if (!FaceMeshCtor) {
        setStatus('FaceMesh library is still unavailable after loading. Refresh the page.', 'error');
        setStartLoading(false);
        startBtn.disabled = false;
        return;
      }

      const CameraCtor = getCameraCtor();
      if (!CameraCtor) {
        setStatus('Camera utils script did not load. Refresh and retry.', 'error');
        setStartLoading(false);
        startBtn.disabled = false;
        return;
      }

      try {
        faceMesh = new FaceMeshCtor({
          locateFile: (file) => {
            if (loadedScripts.has('libs/face_mesh.js') && LOCAL_FACE_MESH_ASSETS.has(file)) {
              return `libs/${file}`;
            }
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
          }
        });

        faceMesh.setOptions({
          maxNumFaces: 1,
          refineLandmarks: true,
          minDetectionConfidence: 0.6,
          minTrackingConfidence: 0.6
        });

        faceMesh.onResults(onResults);

        camera = new CameraCtor(video, {
          onFrame: async () => {
            await faceMesh.send({ image: video });
          },
          width: 1280,
          height: 720
        });

        setStatus(getStatusMessage('statusStartingCamera'));
        await camera.start();
        if (stagePlaceholder) {
          // Fade placeholder once live feed is running.
          stagePlaceholder.classList.add('hidden');
        }
        setStartLoading(false);
        trackingActive = true;
        stopBtn.disabled = false;
        setStatus(getStatusMessage('statusMoveIntoView'), 'ready');
      } catch (error) {
        setStatus('Camera setup failed: ' + (error?.message || String(error)), 'error');
        stop({ silent: true });
      } finally {
        if (!trackingActive) {
          startBtn.disabled = false;
          setStartLoading(false);
        }
      }
    }

    function stop(options = {}) {
      const silent = options.silent === true;
      trackingActive = false;

      if (camera) {
        camera.stop();
        camera = null;
      }

      if (video.srcObject) {
        for (const track of video.srcObject.getTracks()) {
          track.stop();
        }
        video.srcObject = null;
      }

      if (faceMesh && typeof faceMesh.close === 'function') {
        faceMesh.close();
      }
      faceMesh = null;
      smoothedPose = null;
      fadeHat();
      stopBtn.disabled = true;
      startBtn.disabled = false;
      setStartLoading(false);
      if (stagePlaceholder) {
        // Restore placeholder when the session stops.
        stagePlaceholder.classList.remove('hidden');
      }
      if (!silent) {
        setStatus(getStatusMessage('statusIdle'), 'idle');
      }
    }

    function handleNameInput() {
      const text = nameInput.value.trim();
      if (text) {
        hatName.textContent = text.toUpperCase();
      } else {
        hatName.textContent = '';
        hatName.style.opacity = 0;
      }
    }

    sizeRange.addEventListener('input', () => {
      sizeMultiplier = parseFloat(sizeRange.value);
      smoothedPose = null;
    });

    centerBtn.addEventListener('click', () => {
      smoothedPose = null;
      setStatus(getStatusMessage('statusReset'), 'warn');
    });

    nameInput.addEventListener('input', handleNameInput);
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', () => stop());
    window.addEventListener('resize', () => {
      smoothedPose = null;
    });
    video.addEventListener('loadedmetadata', () => {
      smoothedPose = null;
    });
    window.addEventListener('beforeunload', () => stop({ silent: true }));

    // Initialize with Arabic language
    setLanguage('ar');
    setStatus(getStatusMessage('waitingToBegin'), 'idle');
    handleNameInput();
    fadeHat();
  </script>
</body>
</html>
